
#+TITLE: Advent Of Code 2020, Perl Golfing

* Using this file

Load in emacs org-mode, and enable shell evaluation. To do this, Alt-X
'customize-variable' 'org-babel-load-languages', then add shell to the
list of loaded languages.

If you hit C-c C-c in any code block, it will run the script with the
provided parameters, and the result of the script will be displayed
in the mini-buffer at the bottom of the screen. It is set up to expect
the input to be available as dayN_full.input in the current directory
(my inputs are checked in alongside the org file in this repo).

If you update the :results header parameter in a BEGIN_SRC block to
'output verbatim', you can see the verbatim output of the run, this is
often useful when you are trying to debug something.

* Day 1

** Problem 1

#+BEGIN_SRC bash :cmdline <day1_full.input :results value silent
perl -e '@F=<>;@q=grep{$_->[0]+$_->[1]==2020}map{$a=$_;map{[$a,$_]}grep{$_>=1010}@F}grep{$_<1010}@F;print$q[0]->[0]*$q[0]->[1];'
#+END_SRC

** Problem 2

#+BEGIN_SRC bash :cmdline <day1_full.input :results value silent
perl -e 'sub x{my($l,$h,@t)=@_;$l+1>@_?():$l>1?((map{[$h,@{$_}]}x($l-1,@t)),x($l,@t)):([$h],map{[$_]}@t)};@q=@{(grep{@b=@{$_};$b[0]+$b[1]+$b[2]==2020}x(3,<>))[0]};print$q[0]*$q[1]*$q[2];'
#+END_SRC

* Day 2

** Problem 1

#+BEGIN_SRC bash :cmdline <day2_full.input :results value silent
perl -ne '/(.+)-(.+) (.):/;$c=grep{$_ eq$3}split("",$'\'');$a+=$c>=$1&&$c<=$2;END{print$a}' 
#+END_SRC

** Problem 2

#+BEGIN_SRC bash :cmdline <day2_full.input :results value silent
perl -ne '/(.+)-(.+) (.):/;@c=split"",$'\'';$a++if$c[$1]eq$3 xor $c[$2]eq$3;END{print$a}'
#+END_SRC

* Day 3

** Problem 1

#+BEGIN_SRC bash :cmdline <day3_full.input :results value silent
perl  -F'' -anle '$a++if$F[$x]eq"#";($x+=3)%=$#F+1;END{print$a}'
#+END_SRC

** Problem 2

#+BEGIN_SRC bash  :cmdline <day3_full.input :results value silent
perl -F'' -alne 'BEGIN{@a=((map{[1,$_]}(1,3,5,7)),[2,1])};@a=map{@b=@{$_};($l%$b[0])<1?[$b[0],$b[1],($b[2]+$b[1])%($#F+1),($F[$b[2]]eq"#"?$b[3]+1:$b[3])]:$_}@a;$l++;END{print(eval(join("*",map{$_->[3]}@a)))}'
#+END_SRC

* Day 4

** Problem 1

#+BEGIN_SRC bash :cmdline <day4_full.input :results value silent
perl -00 -F'[\s:]' -ape '%f=@F;$a+=1>grep{not$f{$_}}("byr","iyr","eyr","hgt","hcl","ecl","pid");$_="";END{print$a}'
#+END_SRC

** Problem 2

#+BEGIN_SRC bash :cmdline <day4_full.input :results value silent
perl -00 -F'[\s:]' -ape '%c=(byr=>">1919&&\$v<2003",iyr=>">2009&&\$v<2021",eyr=>">2019&&\$v<2031",hgt=>"=~/^((\\d{3})cm|(\\d\\d)in)\$/&&((\$2>149&&\$2<194)||(\$3>58&&\$3<77))",hcl=>"=~/^#[0-9a-f]{6}\$/",ecl=>"=~/^(amb|blu|brn|gr[ny]|hzl|oth)\$/",pid=>"=~/^\\d{9}\$/");%f=@F;$a+=1>grep{not eval("sub{\$v=\$_[0];\$v$c{$_}}")->($f{$_})}keys(%c);$_="";END{print$a}'
#+END_SRC

* Day 5

** Problem 1

#+BEGIN_SRC bash :cmdline <day5_full.input :results value silent
perl -e 'print(eval((sort(map{tr/FLBR/001/;"0b$_"}<>))[-1]));'
#+END_SRC

** Problem 2

#+BEGIN_SRC bash :cmdline <day5_full.input :results value silent
perl -e '@q=map{eval}sort(map{tr/FLBR/001/;"0b$_"}<>);$c=$q[0];map{$c=$_+1if$c==$_}@q;print$c'
#+END_SRC

* Day 6

** Problem 1

#+BEGIN_SRC bash :cmdline <day6_full.input :results value silent
perl -00 -F'\s*' -ne '%f=map{($_,1)}@F;$a+=%f;END{print$a}'
#+END_SRC

** Problem 2

#+BEGIN_SRC bash :cmdline <day6_full.input :results value silent
perl -00 -F'\n' -ne '%f=();(map{map{$f{$_}+=1}split""}@F);$a+=grep{$f{$_}==@F}%f;END{print$a}'
#+END_SRC

* Day 7

** Problem 1

#+BEGIN_SRC bash :cmdline <day7_full.input :results value silent
perl -e '%g=%f=();map{@f=split(/ *bags?(?:[,.](?: \d+)? *| contain (?:\d+|no other bags.) *)/);$k=shift@f;map{push@{$f{$_}},$k}@f}<>;sub t{map{t($_);$g{$_}=1} @{$f{$_[0]}}};t("shiny gold");print 0+%g'
#+END_SRC

** Problem 2

#+BEGIN_SRC bash :cmdline <day7_full.input :results value silent
perl -e '%f=();map{@f=split(/ *bags?(?:[,.]| contain (?:no other bags.)?) */);$k=shift@f;$f{$k}=[map{[/(\d+) (.+)$/]}@f]}<>;sub t{my$c=1;map{$c+=t($_->[1])*$_->[0]}@{$f{$_[0]}};return $c;};print(t("shiny gold")-1);'
#+END_SRC

* Day 8

** Problem 1

#+BEGIN_SRC bash :cmdline <day8_full.input :results value silent
perl -e '@i=map{/(.).. ([+-]\d+)/;[$1,$2]}<>;sub a{$c+=$_[0];$p++;t()};sub n{$p++;t()};sub j{$p+=$_[0];t()};sub t{($v,$x)=@{$i[$p]};++$r[$p]>1?$c:&{$v}($x)}print t();'
#+END_SRC

*** Statement By Statement Breakdown

**** Parsing the instructions into a useable form
#+BEGIN_SRC perl
@i=map{/(.).. ([+-]\d+)/;[$1,$2]}<>
#+END_SRC

This map processes the entire source file (~<>~ is called in array
context, so returns an array of all the lines in the file), and pulls
out the first character of each instruction, and the operand, using
the regular expression ~/(.).. ([+-]\d+)/~. This implicitly puts the
two groups in the regexp into ~$1~ and ~$2~, which are then return for each line as an array reference ~[$1,$2]~

The reason for abbreviating the instruction names to a unique single
character is to allow us to use a single character name later for the
subroutine that implements each instruction.

After this line has run, ~@i~ contains the abbreviated instructions and operands

**** Subroutine Implementing 'acc'

#+BEGIN_SRC perl
sub a{$c+=$_[0];$p++;t()}
#+END_SRC

This subroutine implements the abbreviated 'acc' instruction
(abbreviated to a). Basically, it adds the operand to the accumulator
(~$c~), and increments the program counter (~$p~) by one. It then
calls ~t()~, which is the interpreter, to continue interpreting the
result. Calling ~t()~ at the end of the functio like this results in
the return value of ~t()~ being implicitly used as the return value
for this function.

Note that both ~$c~ and ~$p~ are uninitialized - the first time either of
them are used, they will be treated as 0, and incremented
appropriately. Also, The operand is a string, but perl will
automatically coerce it to a numeric value, as we are trying to add.

**** Subroutine implementing 'nop'

#+BEGIN_SRC perl
sub n{$p++;t()}
#+END_SRC

The nop subroutine just increments the program counter, and calls ~t()~ to continue interpreting.

**** Subroutine implement 'jmp'

#+BEGIN_SRC perl
sub j{$p+=$_[0];t()}
#+END_SRC

The 'jmp' subroutine updates the program counter by the operand
(coerced by perl from a string), and continues interpreting.

**** Interpreter

#+BEGIN_SRC perl
sub t{($v,$x)=@{$i[$p]};++$r[$p]>1?$c:&{$v}($x)}
#+END_SRC

The interpreter is fairly simple:

 - It first accesses ~$i[$p]~, which is the current instruction. This
   is an array reference, so we convert it to an array using ~@{...}~,
   and then assign that into two variables ~$v~ and ~$x~. ~$v~ is the
   abbreviated instruction, and ~$x~ is the operand.

 - It then ~++$r[$p]~ increments a counter for the particular line we
   are about to run to see if it has been referenced before. The array
   is implicitly empty, and when we reference a line for the first
   time the item at index ~p~ will be empty, and thus implicitly 0,
   and gets updated to 1

 - This is then compared to see if it is greater than 1 - ~++$r[$p]>1~. 

 - If it is, we have reached the end, as we are running a line we have
   already run before, and are in an infinite loop. So we just return
   the value of the accumulator $c (implicitly)

 - If it has not been run again, we call the function related to the
   operand. This uses the fact that we can get perl to dereference a
   string to a function name using e.g ~&{"a"}(arg1,arg2)~. In this
   case, we are using the ~$v~ we extracted (the abbreviated
   instruction name) as the function name, and the ~$x~ (the operand)
   as the only parameter passed in. The result of this called function
   is implicitly returned as the result of the interpreter function.

*** Invocation

#+BEGIN_SRC perl
print t();
#+END_SRC

Finally, we invoke the interpreter function ~t()~, and return the
result.

** Problem 2

#+BEGIN_SRC bash :cmdline <day8_full.input :results value silent
perl -e '@j=map{/(.).. ([+-]\d+)/;[$1,$2]}<>;@l=grep{$j[$_]->[0]=~/[nj]/}0..$#j;sub a{$c+=$_[0];$p++;t()};sub n{$p++;t()};sub j{$p+=$_[0];t()};sub t{($v,$x)=@{$i[$p]};$p>$#i?($c,0):++$r[$p]>1?($c,1):&{$v}($x)};print((grep{$_->[1]==0}map{$c=0;$p=0;@r=();@i=map{[@{$_}]}@j;$i[$_]->[0]=~tr/nj/jn/;[t()]}@l)[0]->[0])'
#+END_SRC

* Day 9

** Problem 1

#+BEGIN_SRC bash :cmdline <day9_full.input :results value silent
perl -le '@a=map{0+$_}<>;
@p=map{shift@a}1..25;
print((grep{%f=map{$q=$_;map{($q+$_,1)}(grep{$q!=$_}@p)}@p;shift@p;push@p,$_;not $f{$_}}@a)[0])'
#+END_SRC

** Problem 2

#+BEGIN_SRC bash :cmdline <day9_full.input :results value silent
perl -le 'use List::Util qw[min max];
@a=map{0+$_}<>;@r=(map{$p=$_,$v=$a[$p];map{[$p,$_,$v+=$a[$_]]}($_+1)..$#a}0..$#a);
($s,$e)=@{((grep{$_->[2]==756008079}@r)[0])};
@v=@a[$s..$e];
print min(@v)+max(@v)'
#+END_SRC


* Day 10
** Problem 1

#+BEGIN_SRC bash :cmdline <day10_full.input :results value silent
perl -e 'map{$a[$_-$x]++;$x=$_}(sort{$a<=>$b}(<>));print($a[1]*($a[3]+1))' 
#+END_SRC

*** Statement By Statement

This is essentially just counting the differences between the joltages of consecutive adapters

#+BEGIN_SRC perl
sort{$a<=>$b}(<>)
#+END_SRC

This sorts the input in numeric order. Unfortunately, by default sorts
in perl are lexicographically ordered by default, so we have to
explicily specify numeric order. The ~<=>~ 'spaceship' operator is
used for this.

#+BEGIN_SRC perl
  map{$a[$_-$x]++;$x=$_}(sort{$a<=>$b}(<>))
#+END_SRC

  We then map across the results of the sort, and increment one of an
  array of counters based on the difference between this element and
  the previous ~$x~. We then set ~$x~ to the current element, so it's
  ready for the next entry. Part of the trick here is that ~$x~ is
  undefined at the beginning, which is implicitly 0. However, we are
  including the difference from 0 to the first adapter, so this works
  for us.

#+BEGIN_SRC perl
  print($a[1]*($a[3]+1))
#+END_SRC

When the map is complete, we have an array of the counts of
differences, and we can just multiply the count of 1 jolt differences
to the count of 3 jolt differences.

** Problem 2

#+NAME: day10-problem2
#+BEGIN_SRC bash :cmdline <day10_full.input :results value silent
perl -e '@a=sort{$b<=>$a}(map{$_+0}<>);$f{shift@a}=1;map{$f{$_}=$f{$_+1}+$f{$_+2}+$f{$_+3};}(@a,0);print($f{0})'
#+END_SRC

*** Statement By Statement

#+BEGIN_SRC perl
map{$_+0}<>
#+END_SRC

Reads the file, and converts it into an array of numbers. This is
important later - the hash used to track the number of paths to a
particular voltage would otherwise use the string, which includes a
trailing "\n" that we don't get with the implicit conversion back from
a number.

#+BEGIN_SRC perl
@a=sort{$b<=>$a}(map{$_+0}<>)
#+END_SRC

This is sorting the list of results in reverse. We do this so we get
the largest adapter joltage first, so we can count the number of ways
to get from that to the maximum joltage - which is one, as it's always
3 higher that the largest adapter joltage.

#+BEGIN_SRC perl
$f{shift@a}=1
#+END_SRC

This sets the count for the number of ways from the maximum adapter
joltage to the final joltage to 1, and also removes the first value
from the array.

#+BEGIN_SRC perl
map{$f{$_}=$f{$_+1}+$f{$_+2}+$f{$_+3};}(@a,0)
#+END_SRC

This takes the array of adapters, not including the most powerful
(which was removed in the previous step), and
adds a 0 (for the port joltage) at the end, so we have the entire
chain.  It then runs through the list (which is ordered in reverse),
and sets the count of ways to get to from that joltage to the final
joltage as the sum of the ways to get to each of the next three
joltages. When we're done with this, ~$f{0}~ (the last one to be
calculated) will be the number we are looking for.

#+BEGIN_SRC perl
print($f{0})
#+END_SRC

Prints the result out.
