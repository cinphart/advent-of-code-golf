
#+TITLE: Advent Of Code 2020, Perl Golfing

* Using this file

Load in emacs org-mode, and enable shell evaluation. To do this, Alt-X
'customize-variable' 'org-babel-load-languages', then add shell to the
list of loaded languages.

If you hit C-c C-c in any code block, it will run the script with the
provided parameters, and the result of the script will be displayed
in the mini-buffer at the bottom of the screen. It is set up to expect
the input to be available as dayN_full.input in the current directory
(my inputs are checked in alongside the org file in this repo).

If you update the :results header parameter in a BEGIN_SRC block to
'output verbatim', you can see the verbatim output of the run, this is
often useful when you are trying to debug something.

* Day 1

** Problem 1

#+BEGIN_SRC bash :cmdline <day1_full.input :results value silent
perl -e '@F=<>;@q=grep{$_->[0]+$_->[1]==2020}map{$a=$_;map{[$a,$_]}grep{$_>=1010}@F}grep{$_<1010}@F;print$q[0]->[0]*$q[0]->[1];'
#+END_SRC

*** Statement By Statement

#+BEGIN_SRC perl
@F=<>;
#+END_SRC

This reads the entire file into the @F array, by lines

#+BEGIN_SRC perl
$a=$_;map{[$a,$_]}grep{$_>=1010}@F
#+END_SRC

This is within a map, but it's taking the current value, and then
pairing it with every value from @F that is greater than or equal to
1010

#+BEGIN_SRC perl
map{$a=$_;map{[$a,$_]}grep{$_>=1010}@F}grep{$_<1010}@F
#+END_SRC

This maps the above statement over all items in @F that are less
than 1010. What you end up with is all possible pairs that could add
up to 2020 - assuming no numbers are duplicated, the sum must be made
up of one number less than 1010 and one number > 1010.

#+BEGIN_SRC perl
@q=grep{$_->[0]+$_->[1]==2020}map{...}
#+END_SRC

Takes the result of the previous map, and filters it down to only
pairs that sum to 2020, so that the result in the @q variable is all
pairs (presumably only one, based on the problem) that sum to 2020.

#+BEGIN_SRC perl
print$q[0]->[0]*$q[0]->[1]
#+END_SRC

Calculate the product of the (presumably only) pair that sums to 2020.

** Problem 2

#+BEGIN_SRC bash :cmdline <day1_full.input :results value silent
perl -e 'sub x{my($l,$h,@t)=@_;$l+1>@_?():$l>1?((map{[$h,@{$_}]}x($l-1,@t)),x($l,@t)):([$h],map{[$_]}@t)};@q=@{(grep{@b=@{$_};$b[0]+$b[1]+$b[2]==2020}x(3,<>))[0]};print$q[0]*$q[1]*$q[2];'
#+END_SRC

**** Statement By Statement

#+BEGIN_SRC perl
sub x{
my($l,$h,@t)=@_;
$l+1>@_?()
  :$l>1?((map{[$h,@{$_}]}x($l-1,@t)),x($l,@t))
  :([$h],map{[$_]}@t)}
}
#+END_SRC

This subroutine, given a length l and an array as the parameters,
returns all combinations of length l from the array....

#+BEGIN_SRC perl
my($l,$h,@t)=@_;
#+END_SRC

This just pulls out the argument list into three parts - the length
~l~, the head of list ~h~, and the tail of the list ~t. Perl doesn't
have named arguments, you just get an array, and it's up to you to
destructure it appropriately (or not). In this case, breaking it up
this way gives me a shorthand to use for variables that will be used
in multiple places, and ends up saving me several characters, rather
than just referencing the array elements directly.

The next part is basically three cases:

 1. ~$l~ > total remaining list - in which case, we give up, as we
    don't have enough elements to fulfill the requirement, and return
    the empty list.

 2. ~$l~ > 1, which means we need to combine two things:

   a) ~$t~ + all combinations of size ~$l-1~ from @t

   b) all combinations of ~@t~ of length $l
   
 3. Our final case is if ~$l == 1~, in which case, we just return a copy
    of each element of the current list wrapper as a single element.

These are the following statements, in order:

#+BEGIN_SRC perl
$l+1>@_?()
#+END_SRC

~@_~ is the entire argument list, which is the length plus the full
array, which in scalar context (because it's having ~>~ applied to it)
is implicitly converted to the length of the argument array, which is
one larger than the size of the original array, so we're comparing
~$l+1~ to that. That ternary case returns (), the empty array.

#+BEGIN_SRC perl
  :$l>1?((map{[$h,@{$_}]}x($l-1,@t)),x($l,@t))
#+END_SRC

This is the recursive case, if length > 1, which is returning the concatenation of

#+BEGIN_SRC perl
(map{[$h,@{$_}]}x($l-1,@t))
#+END_SRC perl

  The ~[$h,@{$_}]~ in the map unwraps the array reference returned from
  the call ~@{$_}~ to x, prepends ~$h~, and wraps the whole new array up
  in a reference.

  ...prepending ~$h~ to every ~$l-1~ combination ~x($l-1,@t)~ of the rest of the list to

#+BEGIN_SRC perl
x($l,@t)
#+END_SRC

...which is all combinations of length ~$l~ from the rest of the list ~@t~.

Finally, we have:

#+BEGIN_SRC perl
([$h],map{[$_]}@t)}
#+END_SRC perl

which is invoked if ~$l~ is 1, in which case, we map over the entire
list, returning the parts of the list wrapped as a reference to a
one-item array.

* Day 2

** Problem 1

#+BEGIN_SRC bash :cmdline <day2_full.input :results value silent
perl -ne '/(.+)-(.+) (.):/;$c=grep{$_ eq$3}split("",$'\'');$a+=$c>=$1&&$c<=$2;END{print$a}' 
#+END_SRC

** Problem 2

#+BEGIN_SRC bash :cmdline <day2_full.input :results value silent
perl -ne '/(.+)-(.+) (.):/;@c=split"",$'\'';$a++if$c[$1]eq$3 xor $c[$2]eq$3;END{print$a}'
#+END_SRC

* Day 3

** Problem 1

#+BEGIN_SRC bash :cmdline <day3_full.input :results value silent
perl  -F'' -anle '$a++if$F[$x]eq"#";($x+=3)%=$#F+1;END{print$a}'
#+END_SRC

** Problem 2

#+BEGIN_SRC bash  :cmdline <day3_full.input :results value silent
perl -F'' -alne 'BEGIN{@a=((map{[1,$_]}(1,3,5,7)),[2,1])};@a=map{@b=@{$_};($l%$b[0])<1?[$b[0],$b[1],($b[2]+$b[1])%($#F+1),($F[$b[2]]eq"#"?$b[3]+1:$b[3])]:$_}@a;$l++;END{print(eval(join("*",map{$_->[3]}@a)))}'
#+END_SRC

* Day 4

** Problem 1

#+BEGIN_SRC bash :cmdline <day4_full.input :results value silent
perl -00 -F'[\s:]' -ape '%f=@F;$a+=1>grep{not$f{$_}}("byr","iyr","eyr","hgt","hcl","ecl","pid");$_="";END{print$a}'
#+END_SRC

** Problem 2

#+BEGIN_SRC bash :cmdline <day4_full.input :results value silent
perl -00 -F'[\s:]' -ape '%c=(byr=>">1919&&\$v<2003",iyr=>">2009&&\$v<2021",eyr=>">2019&&\$v<2031",hgt=>"=~/^((\\d{3})cm|(\\d\\d)in)\$/&&((\$2>149&&\$2<194)||(\$3>58&&\$3<77))",hcl=>"=~/^#[0-9a-f]{6}\$/",ecl=>"=~/^(amb|blu|brn|gr[ny]|hzl|oth)\$/",pid=>"=~/^\\d{9}\$/");%f=@F;$a+=1>grep{not eval("sub{\$v=\$_[0];\$v$c{$_}}")->($f{$_})}keys(%c);$_="";END{print$a}'
#+END_SRC

* Day 5

** Problem 1

#+BEGIN_SRC bash :cmdline <day5_full.input :results value silent
perl -e 'print(eval((sort(map{tr/FLBR/001/;"0b$_"}<>))[-1]));'
#+END_SRC

** Problem 2

#+BEGIN_SRC bash :cmdline <day5_full.input :results value silent
perl -e '@q=map{eval}sort(map{tr/FLBR/001/;"0b$_"}<>);$c=$q[0];map{$c=$_+1if$c==$_}@q;print$c'
#+END_SRC

* Day 6

** Problem 1

#+BEGIN_SRC bash :cmdline <day6_full.input :results value silent
perl -00 -F'\s*' -ne '%f=map{($_,1)}@F;$a+=%f;END{print$a}'
#+END_SRC

** Problem 2

#+BEGIN_SRC bash :cmdline <day6_full.input :results value silent
perl -00 -F'\n' -ne '%f=();(map{map{$f{$_}+=1}split""}@F);$a+=grep{$f{$_}==@F}%f;END{print$a}'
#+END_SRC

* Day 7

** Problem 1

#+BEGIN_SRC bash :cmdline <day7_full.input :results value silent
perl -e '%g=%f=();map{@f=split(/ *bags?(?:[,.](?: \d+)? *| contain (?:\d+|no other bags.) *)/);$k=shift@f;map{push@{$f{$_}},$k}@f}<>;sub t{map{t($_);$g{$_}=1} @{$f{$_[0]}}};t("shiny gold");print 0+%g'
#+END_SRC

** Problem 2

#+BEGIN_SRC bash :cmdline <day7_full.input :results value silent
perl -e '%f=();map{@f=split(/ *bags?(?:[,.]| contain (?:no other bags.)?) */);$k=shift@f;$f{$k}=[map{[/(\d+) (.+)$/]}@f]}<>;sub t{my$c=1;map{$c+=t($_->[1])*$_->[0]}@{$f{$_[0]}};return $c;};print(t("shiny gold")-1);'
#+END_SRC

* Day 8

** Problem 1

#+BEGIN_SRC bash :cmdline <day8_full.input :results value silent
perl -e '@i=map{/(.).. ([+-]\d+)/;[$1,$2]}<>;sub a{$c+=$_[0];$p++;t()};sub n{$p++;t()};sub j{$p+=$_[0];t()};sub t{($v,$x)=@{$i[$p]};++$r[$p]>1?$c:&{$v}($x)}print t();'
#+END_SRC

*** Statement By Statement Breakdown

**** Parsing the instructions into a useable form
#+BEGIN_SRC perl
@i=map{/(.).. ([+-]\d+)/;[$1,$2]}<>
#+END_SRC

This map processes the entire source file (~<>~ is called in array
context, so returns an array of all the lines in the file), and pulls
out the first character of each instruction, and the operand, using
the regular expression ~/(.).. ([+-]\d+)/~. This implicitly puts the
two groups in the regexp into ~$1~ and ~$2~, which are then return for each line as an array reference ~[$1,$2]~

The reason for abbreviating the instruction names to a unique single
character is to allow us to use a single character name later for the
subroutine that implements each instruction.

After this line has run, ~@i~ contains the abbreviated instructions and operands

**** Subroutine Implementing 'acc'

#+BEGIN_SRC perl
sub a{$c+=$_[0];$p++;t()}
#+END_SRC

This subroutine implements the abbreviated 'acc' instruction
(abbreviated to a). Basically, it adds the operand to the accumulator
(~$c~), and increments the program counter (~$p~) by one. It then
calls ~t()~, which is the interpreter, to continue interpreting the
result. Calling ~t()~ at the end of the functio like this results in
the return value of ~t()~ being implicitly used as the return value
for this function.

Note that both ~$c~ and ~$p~ are uninitialized - the first time either of
them are used, they will be treated as 0, and incremented
appropriately. Also, The operand is a string, but perl will
automatically coerce it to a numeric value, as we are trying to add.

**** Subroutine implementing 'nop'

#+BEGIN_SRC perl
sub n{$p++;t()}
#+END_SRC

The nop subroutine just increments the program counter, and calls ~t()~ to continue interpreting.

**** Subroutine implement 'jmp'

#+BEGIN_SRC perl
sub j{$p+=$_[0];t()}
#+END_SRC

The 'jmp' subroutine updates the program counter by the operand
(coerced by perl from a string), and continues interpreting.

**** Interpreter

#+BEGIN_SRC perl
sub t{($v,$x)=@{$i[$p]};++$r[$p]>1?$c:&{$v}($x)}
#+END_SRC

The interpreter is fairly simple:

 - It first accesses ~$i[$p]~, which is the current instruction. This
   is an array reference, so we convert it to an array using ~@{...}~,
   and then assign that into two variables ~$v~ and ~$x~. ~$v~ is the
   abbreviated instruction, and ~$x~ is the operand.

 - It then ~++$r[$p]~ increments a counter for the particular line we
   are about to run to see if it has been referenced before. The array
   is implicitly empty, and when we reference a line for the first
   time the item at index ~p~ will be empty, and thus implicitly 0,
   and gets updated to 1

 - This is then compared to see if it is greater than 1 - ~++$r[$p]>1~. 

 - If it is, we have reached the end, as we are running a line we have
   already run before, and are in an infinite loop. So we just return
   the value of the accumulator $c (implicitly)

 - If it has not been run again, we call the function related to the
   operand. This uses the fact that we can get perl to dereference a
   string to a function name using e.g ~&{"a"}(arg1,arg2)~. In this
   case, we are using the ~$v~ we extracted (the abbreviated
   instruction name) as the function name, and the ~$x~ (the operand)
   as the only parameter passed in. The result of this called function
   is implicitly returned as the result of the interpreter function.

*** Invocation

#+BEGIN_SRC perl
print t();
#+END_SRC

Finally, we invoke the interpreter function ~t()~, and return the
result.

** Problem 2

#+BEGIN_SRC bash :cmdline <day8_full.input :results value silent
perl -e '@j=map{/(.).. ([+-]\d+)/;[$1,$2]}<>;@l=grep{$j[$_]->[0]=~/[nj]/}0..$#j;sub a{$c+=$_[0];$p++;t()};sub n{$p++;t()};sub j{$p+=$_[0];t()};sub t{($v,$x)=@{$i[$p]};$p>$#i?($c,0):++$r[$p]>1?($c,1):&{$v}($x)};print((grep{$_->[1]==0}map{$c=0;$p=0;@r=();@i=map{[@{$_}]}@j;$i[$_]->[0]=~tr/nj/jn/;[t()]}@l)[0]->[0])'
#+END_SRC

* Day 9

** Problem 1

#+BEGIN_SRC bash :cmdline <day9_full.input :results value silent
perl -le '@a=map{0+$_}<>;
@p=map{shift@a}1..25;
print((grep{%f=map{$q=$_;map{($q+$_,1)}(grep{$q!=$_}@p)}@p;shift@p;push@p,$_;not $f{$_}}@a)[0])'
#+END_SRC

** Problem 2

#+BEGIN_SRC bash :cmdline <day9_full.input :results value silent
perl -le 'use List::Util qw[min max];
@a=map{0+$_}<>;@r=(map{$p=$_,$v=$a[$p];map{[$p,$_,$v+=$a[$_]]}($_+1)..$#a}0..$#a);
($s,$e)=@{((grep{$_->[2]==756008079}@r)[0])};
@v=@a[$s..$e];
print min(@v)+max(@v)'
#+END_SRC


* Day 10
** Problem 1

#+BEGIN_SRC bash :cmdline <day10_full.input :results value silent
perl -e 'map{$a[$_-$x]++;$x=$_}(sort{$a<=>$b}(<>));print($a[1]*($a[3]+1))' 
#+END_SRC

*** Statement By Statement

This is essentially just counting the differences between the joltages of consecutive adapters

#+BEGIN_SRC perl
sort{$a<=>$b}(<>)
#+END_SRC

This sorts the input in numeric order. Unfortunately, by default sorts
in perl are lexicographically ordered, so we have to
explicily specify numeric order. The ~<=>~ 'spaceship' operator is
used for this.

#+BEGIN_SRC perl
  map{$a[$_-$x]++;$x=$_}(sort{$a<=>$b}(<>))
#+END_SRC

  We then map across the results of the sort, and increment one of an
  array of counters based on the difference between this element and
  the previous ~$x~. We then set ~$x~ to the current element, so it's
  ready for the next entry. Part of the trick here is that ~$x~ is
  undefined at the beginning, which is implicitly 0. However, we are
  including the difference from 0 to the first adapter, so this works
  for us.

#+BEGIN_SRC perl
  print($a[1]*($a[3]+1))
#+END_SRC

When the map is complete, we have an array of the counts of
differences, and we can just multiply the count of 1 jolt differences
to the count of 3 jolt differences. One tricky thing - the question
actually asks includes the final jump to the laptop, which is always 3
larger than the highest adapter joltage. So we add one to the count of
3 jolt differences to correct for this.

** Problem 2

#+NAME: day10-problem2
#+BEGIN_SRC bash :cmdline <day10_full.input :results value silent
perl -e '@a=sort{$b<=>$a}(map{$_+0}<>);$f{shift@a}=1;map{$f{$_}=$f{$_+1}+$f{$_+2}+$f{$_+3};}(@a,0);print($f{0})'
#+END_SRC

*** Statement By Statement

#+BEGIN_SRC perl
map{$_+0}<>
#+END_SRC

Reads the file, and converts it into an array of numbers. This is
important later - the hash used to track the number of paths to a
particular voltage would otherwise use the string, which includes a
trailing "\n" that we don't get with the implicit conversion back from
a number.

#+BEGIN_SRC perl
@a=sort{$b<=>$a}(map{$_+0}<>)
#+END_SRC

This is sorting the list of results in reverse. We do this so we get
the largest adapter joltage first, so we can count the number of ways
to get from that to the maximum joltage - which is one, as it's always
3 higher that the largest adapter joltage.

#+BEGIN_SRC perl
$f{shift@a}=1
#+END_SRC

This sets the count for the number of ways from the maximum adapter
joltage to the final joltage to 1, and also removes the first value
from the array.

#+BEGIN_SRC perl
map{$f{$_}=$f{$_+1}+$f{$_+2}+$f{$_+3};}(@a,0)
#+END_SRC

This takes the array of adapters, not including the most powerful
(which was removed in the previous step), and
adds a 0 (for the port joltage) at the end, so we have the entire
chain.  It then runs through the list (which is ordered in reverse),
and sets the count of ways to get to from that joltage to the final
joltage as the sum of the ways to get to each of the next three
joltages. When we're done with this, ~$f{0}~ (the last one to be
calculated) will be the number we are looking for.

For example, if we have a list of adaptors something like:

 - 1,2,5,8,9,10,11,14

we will sort the list in reverse order, set the count for '14' to 1,
as the laptop is 3 higher, so there's only one possible way to get
from 14 to the laptop value, and add a zero to the end of the list, to
represent the port we're initially connecting to. This gives us the
follow to process:

 - 11,10,9,9,8,5,2,1,0

We'll then go through that list in order, calculating the number of ways to get from X to the end as follows:

| Count | Sum                                   | Result |
|-------+---------------------------------------+--------|
|    14 | (initialized to 1)                    |      1 |
|    11 | count(12)+count(13)+count(14) = 0+0+1 |      1 |
|    10 | count(11)+count(12)+count(13) = 1+0+0 |      1 |
|     9 | count(10)+count(11)+count(13) = 1+1+0 |      2 |
|     8 | count(9)+count(10)+count(11) = 2+1+1  |      4 |
|     5 | count(6)+count(7)+count(8) = 0+0+4    |      4 |
|     2 | count(3)+count(4)+count(5) = 0+0+4    |      4 |
|     1 | count(2)+count(3)+count(4) = 4+0+0    |      4 |
|     0 | count(1)+count(2)+count(3) = 4+4+0    |      8 |

Note that we only calculate a value for joltages that we have an
adapter for. There is no way to get to the other joltages, so those
values are always 0.

#+BEGIN_SRC perl
print($f{0})
#+END_SRC

Prints the result out.
